QSP-Game распечатка содержимого нескольких массивов. Удобно для вывода данных

!@ $0 - ... $18 — имена массивов, содержимое которых необходимо просмотреть.
!@ $18 - ... $1 - управляющая конструкция. Записывается последним аргументом. См ниже.
!@pp:if(em_fewarrs_print):include
# em.fewArrs.print
args[21]=arrsize('$args')-1	& !@ получаем номер последнего аргумента
!@ получаем позицию неверно записанного названия массива
args[24] = arrcomp('$args','[\s\S]*((\b\d+([A-Za-zа-яА-Я\$\%\._]+\d*)+\b)|(\b[A-Za-zа-яА-Я\$\%\._]+[^A-Za-zа-яА-Я\$\%\._]+))[\s\S]*')
args[22] = iif($strfind($args[args[21]],'\[.+?\]')<>'', 1, 0)
$args[23] = 'Error: All your massives are empty.'
if args[24]<>-1 and args[24]<>args[21]:
	!@ если мы имеем дело не с командой, и это не последний аргумент, значит имя массива задано неверно, возвращаем 
	msg "em.fewArrs.print: Array's name is not correct. ARGS[<<args[24]>>]: '<<$args[args[24]]>>'"
	exit
end
!@ символ переноса строки
args[25], args[26] = 0, -1
if args[22]:
	!@ если последний аргумент содержит хотя бы один пробел, его нельзя считать названием массива
	!@ скорее всего это управляющая конструкция. Либо это действительно управляющая конструкция.
	$args[30]=$lcase($args[args[21]])	& !@ переводим в нижний регистр
	!@ по управляющей конструкции понимаем, нужно строить таблицу или нет
	args[27] = iif(instr($args[30],'[no table]'), 0, 1)
	!@ по управляющей конструкции понимаем, нужно ли выводить одни только результаты
	if instr($args[30],'[only result]'): args[27], args[28] = 0, 1
	!@ получаем номера первого и последнего элементов, которые хотим вывести
	if instr($args[30], '[range onscreen:'):
		args[25] = $strfind($args[30], '\[range onscreen:(\d+)\-\d+\]', 1)
		!@ вместо последнего элемента нам нужен следующий за последним
		args[26] = $strfind($args[30], '\[range onscreen:\d+\-(\d+)\]', 1) + 1
	end
	if instr($args[30], '[empty:'):
		$args[23] = $strfind($args[args[21]], '(\[empty:)(.+?)\]', 2)
	end
	args[21] -= 1
else:
	args[27] = 1
	args[28] = 0
end
:print
!@ если списка команд нет, или управление не отключает генерацию таблицы, добавляем теги таблицы.
if args[27] or no args[22]: $args[29]='<table border=1 cellpadding=5>'
if args[27]: $args[29] += '<tr><td>#</td>'

!@ с помощью цикла добавляем имена массивов в список
loop args['i']=0 while args['i']<args[21]+1 and $strfind($args[args['i']],'\[.+?\]')='' and $args[args['i']]<>'' step args['i']+=1:
	!@ пока счётчик не достигнет девяти, или мы не встретим аргумент с управлением, или пустой аргумент
	if args[27]: $args[29] += "<td><<$args[args['i']]>></td>"	& !@ создаём ячейку, только если уже набираем таблицу
	args['this_size']=arrsize($args[args['i']])	& !@ получаем размер указанного массива
	if args['this_size']>args['size']: args['size']=args['this_size']	& !@ если размер этого массива больше размера предыдущего массива, записываем размер текущего в переменную size
end

if args[27]: $args[29] += '</tr>'	& !@ закрываем строку

if args['size']=0:
	!@ если размеры всех массивов равны нулю, выводим сообщениме.
	$result = $args[23]
	exit
end
if args[25] > args['size'] - 1:
	!@ если мы превысили максимальный индекс, нужно приравнять начало к последнему возможному индексу
	args[25] = args['size'] - 1
end
if args[26] > args['size'] or args[26] = -1:
	args[26] = args['size']
elseif args[26] <= args[25]:
	args[26] = args[25] + 1
end
!@ следующий цикл выводит уже непосредственно результаты
loop args['b']=args[25] while args['b']<args[26] step args['b']+=1:
	!@ пока счётчик не достигнет размера самого большого массива
	if args[27]: $args[29] += "<tr><td><<args['b']>></td>"	& !@ для вывода в виде таблицы формируем строку и первую ячейку
	!@ этот цикл выводит содержимое ячеек под одним индексом
	loop args['i']=0 while args['i']<args[21]+1 and $strfind($args[args['i']],'\[.+?\]')='' and $args[args['i']]<>'' step args['i']+=1:
		!@ пока счётчик не достигнет девяти, или мы не встретим аргумент с управлением, или пустой аргумент
		if no args[28] and no args[27]:
			!@ это не режим только результат, но и не режим вывода таблицы
			$args['cell']=$args[args['i']]+"[<<args['b']>>]="	& !@ перед добавляением значения, добавляем название массива и номер ячейки
		else
			!@ это режим только результат, или режим вывода таблицы
			$args['cell']=''	& !@ не добавляем ничего
		end
		if instr($args[args['i']],'%')=1:
			$args['cell'] += @em.html.to_mnemonics($str(%arritem($args[args['i']],args['b'])))
		elseif instr($args[args['i']],'$')=1:
			!@ выводим строковые значения массива
			if args[27]:
				!@ если мы имеем дело с таблицей
				$args['cell']+=$dyneval({
					!@ $1 - название массива
					!@ $0 - номер ячейки
					if $arritem($args[1],args[0])<>'':
						$result = @em.html.to_mnemonics($arritem($args[1],args[0]))
					else
						!@ в пустых ячейках ставим пробелы
						$result = '&nbsp;'
					end
				},args['b'],$args[args['i']])
			else
				!@ для не таблицы просто добавляем значение
				if no args[28]:
					$args['cell']+="'"+$replace($arritem($args[args['i']],args['b']),"'","''")+"'"
				else
					$args['cell'] += $arritem($args[args['i']],args['b'])
				end
			end
		else:
			!@ выводим числовые значения массива или кортежи
			$args['cell']+=$str(arritem($args[args['i']], args['b']))
		end
		if args[27]:
			$args[29] += '<td>'+$args['cell']+'</td>'	& !@ для таблицы создаём ячейку
		elseif args[28] and args['i']<>0:
			$args['result']+='	'+$args['cell']	& !@ для не таблицы добавляем отступ
		elseif args['i']<>0:
			$args['result']+='	&	'+$args['cell']	& !@ для не таблицы добавляем отступ
		else:
			$args['result']+=$args['cell']
		end
	end
	if args[27]:
		$args[29] += "</tr>"
	elseif args['b']+1<args[26]:
		$args['result']+=@em.RN	& !@ для таблицы закрываем строку, для не таблицы начинаем новую
	end
end
if args[27]: $args[29] += '</table>'

if args[27]:
	$result = $args[29]	& !@ если сгенерирована таблица, возвращаем таблицу
elseif $args['result']<>'':
	$result = $args['result']
else
	msg 'em.fewArrs.print: If you see this message, that so wrong. Save the game and ask me on aleksversus@mail.ru. Error of easy.math.libs in em.fewArrs.print'
end
--- em.fewArrs.print ---------------------------------
!@pp:endif

!@ $18 - ... $1 Можно использовать следующие конструкции в любых комбинациях:
	* [only result] - выводит только содержимое массивов, не показывая их названий и номеров ячеек. Таблица при этом на экран выводиться не будет.
	* [no table] - выводит массивы на экран, но не облекает их в таблицу.
	* [range onscreen:N-M] - указываем границы вывода
	* [empty:TEXT] - что должна возвращать функция в случае, когда все массивы пустые.

!@ #21 - номер последнего элемента в переданных данных
!@ #22 - маркер last is command
!@ $23 - что будет выводиться, если все массивы пусты.
!@ #24 - номер элемента, который содержит неверное имя массива
!@ #25 - с какого элемента начинать вывод
!@ #26 - до какого элемента продолжать вывод
!@ #27 - show table (0|1)
!@ #28 - only result (0|1)
!@ $29 - сюда складывается таблица
!@ $30 - конструкция с командами


Из-за того, что данная функция работает напрямую с данными из массивов было решено не использовать здесь локальные переменные,
чтобы случайно не перекрыть возможные названия массивов.

Функция не использует иных функций библиотеки

$a[]='нулевая ячейка'
$a[]='   первая ячейка   '
$a[]=' вторая ячейка'
$a[]=''
$a[]='четвёртая'' ячейка'
$a[]="   пятая яче'йка"
$a[]=''
$a[]='седьмая ячейка'

$b[]='нулевая ячейка'
$b[]='   первая ячейка   '
$b[]=' вторая ячейка'
$b[]='3'
$b[]=(3,5,6,'string',6)
$b[]='   пятая ячейка'
$b[]='6'
$b[]='7'
usehtml=1
@em.fewArrs.print('$a','$b')
@em.fewArrs.print('$a','$b','[only result]')
@em.fewArrs.print('$a','$b','[no table]')
@em.fewArrs.print('$c','$d')
@em.fewArrs.print('$a','$b','[no table]','$f')

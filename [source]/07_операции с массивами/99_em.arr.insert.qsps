QSP-Game Вставка элемента в массив со сдвигом вправо.

!@ $0 - название массива.
!@ $1 - значение, которое хотим присвоить элементу. (тип определяется по префиксу названия массива)
!@ #2 - индекс элемента, куда хотим поместить новое значение.
!@pp:if(em_arr_insert):include
# em.arr.insert
local em_arr_insert_copy_array_1, em_arr_insert_copy_array_2
if instr($args[0],'%')=1:
	$args[21]='%'
	$args[22]=$str(%args[1])
elseif instr($args[0],'$')=1:
	!@ если имеем дело с текстовым массивом
	$args[21]='$'	& !@ выставляем переменной-маркеру значение '$' (используется как префикc названию массива)
	$args[22]="'<<$args[1]>>'"	& !@ для dyneval и dynamic значение из аргумента замыкаем в апострофы
else
	!@ если имеем дело с числовым массивом
	$args[21]=''	& !@ переменная-маркер с пустым значением
	$args[22]=$str(args[1])	& !@ для dyneval и dynamic значение из аргумента просто приводится к строке
end
copyarr "em_arr_insert_copy_array_1",$args[0],0,args[2]	& !@ копируем во временный массив первую часть исходного массива
copyarr "em_arr_insert_copy_array_2",$args[0],args[2]	& !@ копируем во второй временный массив вторую часть исх. массива
!@ была мысль избавиться от dynamic и использовать arritem, однако
!@ для использования arritem всё равно нужно заранее знать, какого типа значение
!@ я пытаюсь извлечь из массива. В принципе можно написать два одинаковых цикла для того и другого случая,
!@ но тогда мне вообще не нужен dynamic и arritem.
dynamic "
!@pp:вставляем элемент в конец массива
	<<$args[21]>>em_arr_insert_copy_array_1[]=<<$args[22]>>
!@pp:циклом переносим из временного массива вторую часть массива в исходный
	loop while arrsize('<<$args[21]>>em_arr_insert_copy_array_2')>0:
		<<$args[21]>>em_arr_insert_copy_array_1[]=<<$args[21]>>em_arr_insert_copy_array_2[0]
		killvar '<<$args[21]>>em_arr_insert_copy_array_2',0
	end
"
copyarr $args[0],"<<$args[21]>>em_arr_insert_copy_array_1"	& !@ копируем обратно в исходный массив первую часть из временного массива
--- em.arr.insert ---------------------------------
!@pp:endif

Функция не использует иных функций библиотеки, однако поскольку используется цикл, функция довольно медленная. Для сто тысячного массива вставка элемента ближе к началу массива занимает около 8 секунд.

$args[21] - перменная-маркер, указывающая тип массива. '$' - означает, что массив строковый, иначе - числовой.
$args[22] - приведённое к строке значение, которое хотим вставить в массив

mass[0]=574
mass[1]=668
mass[2]=413
mass[3]=765
mass[4]=478
mass[5]=205
mass[6]=701
mass[7]=272

@em.arr.insert('mass',6,4)
@em.arr.print('mass')

%amass[0]=[574, 0]
%amass[1]=[668, 1]
%amass[2]=[413, 2]
%amass[3]=[765, 3]
%amass[4]=[478, 4]
%amass[5]=[205, 5]
%amass[6]=[701, 6]
%amass[7]=[272, 7]

@em.arr.insert('%amass',['inserted'], 3)
loop local i = 0 while i < arrsize('amass') step i+=1:
    *pl %amass[i]
end

QSP-Game Вычисляет рациональное частное от целых чисел.
args[0] - делимое
args[1] - делитель, по умолчанию = 100
args[2] - точность вычисления. 1 - до целых, 10 - до десятых, 100 - до сотых и т.д. По умолчанию, вычисляет до девятого знака после запятой.
$result - текстовое значение вида 000.000
!@pp:if(em_indiv):include
# #indiv#
args[9] = args[9]	& !@ инициализация аргументов
if (args[0]<0 and args[1]>0) or (args[0]>0 and args[1]<0): $args['+']='-'	& !@ если одно из чисел меньше нуля, а другое больше, результат будет отрицательным
if args[0]<0: args[0]=-args[0]	& !@ приводим к модулю
if args[1]<0: args[1]=-args[1]	& !@ приводим к модулю
if args[1]=0: args[1]=100	& !@ если делитель не задан, считается равным 100
if args[2]=0: args[2]=1000000000	& !@ по умолчанию вычисляем частное до девятого знака после запятой (максимальное значение аргумента)
args[2]=len($str(args[2]))	& !@ в args[2] записываем не круглое число, как строку разрядов, а длину этой строки, то есть число разрядов +1
!@ следующий цикл обеспечивает деление по методу `столбиком`.
args['i']=0
:for
	args['rez']=args[0]/args[1]	& !@ получаем частное от деления без остатка
	args['ost']=args[0] mod args[1]	& !@ получаем остаток
	if args['i']=1: $args['res.indiv']+='.'	& !@ если это вторая итеррация, значит пришло время ставить точку
	$args['res.indiv']+=$str(args['rez'])	& !@ к результату деления добавляем строковое значение частного
	args[0]=args['ost']*10	& !@ умножаем остаток на 10, чтобы продолжать вычисление, и теперь это наше новое число
	args['i']+=1	& !@ увеличиваем счётчик
if args['i']<args[2]: jump 'for'	& !@ если счётчик меньше числа разрядов, продолжаем
$args['res.indiv']=$args['+']+$func('#dz#',$args['res.indiv'])	& !@ добавляем знак и отсекаем лишние нули
$result=$args['res.indiv']	& !@ возвращаем результат
--- #indiv# ---------------------------------
!@pp:endif

Функция использует функцию delete_zero, она же em.dz, она же #dz#. В новой версии em.float.dz

!@pp:if(em_indiv!=True):nopp
!@pp:var(em_dz)
!@pp:endif
QSP-Game Функция деления любого числа на любое.
$args[0] - делимое, только текстовое
$args[1] - делитель, только текстовое
args[2] - точность 1 -целые- 10 десятые доли, 100 сотые, 1000 - тысячные.
$result - частное, текстовое значение
!@pp:if(em_div):include
# #:#
$args[9]=$args[9]	& !@ инициализация аргументов 
$args[0]=$func('#dz#',$args[0],1)
$args[1]=$func('#dz#',$args[1],1)
if args[2]<1: args[2]=1000
!@ получаем знак
if instr($args[0],'-')=1:
	$args[0]=$mid($args[0],2)
	args['minus']=1-args['minus']
end
if instr($args[1],'-')=1:
	$args[1]=$mid($args[1],2)
	args['minus']=1-args['minus']
end
!@ выставляем метку знака
if args['minus']=1: $args['+']='-' else $args['+']=''
!@ делим на целую и дробную часть
	!@ делимое
if instr($args[0],'.')<>0:
	$args['int_0']=$mid($args[0],1,instr($args[0],'.')-1)
	$args['float_0']=$mid($args[0],instr($args[0],'.')+1)
else:
	$args['int_0']=$args[0]
	$args['float_0']=''
end
args['len_0']=len($args['float_0'])
	!@ делитель
if instr($args[1],'.')<>0:
	$args['int_1']=$mid($args[1],1,instr($args[1],'.')-1)
	$args['float_1']=$mid($args[1],instr($args[1],'.')+1)
else:
	$args['int_1']=$args[1]
	$args['float_1']=''
end
args['len_1']=len($args['float_1'])
!@ приводим дробную часть к одной длине
if args['len_1']>args['len_0']:
	!@ если длина дробной части делителя больше, приводим длину делимого к ней
	$args['float_0']+=$func('#zero#',args['len_1']-args['len_0'])
else
	!@ в противном случае приводим длину делителя к делимому
	$args['float_1']+=$func('#zero#',args['len_0']-args['len_1'])
end
!@ теперь можно подготовить оба числа к работе с ними, как с целыми
$args[0]=$args['int_0']+$args['float_0']
$args[1]=$args['int_1']+$args['float_1']
!@ результат будем записывать в переменную:
$args['результат']='0'
!@ первое приближение для вычисления
$args['приближение']=$mid($args[0],1,len($args[1]))
$args[0]=$mid($args[0],len($args[1])+1)
args['цифра']=0
:for
if args[2]>0:
	$args['вычитание']=$func('#dev#','0'+$args['приближение'],'0'+$args[1])
	if instr($args['вычитание'],'9')=1:
		!@ если при попытке вычесть из приближения делитель, получается отрицательный результат
		!@ переходим к следующему разряду, т.е.
		$args['результат']+=$str(args['цифра'])	& !@ набраную цифру приписываем к результату
		args['цифра']=0
		if len($args[0])>0:
			!@ если есть из чего набирать числа, добираем следующую цифру
			$args['приближение']+=$mid($args[0],1,1)
			$args[0]=$mid($args[0],2)
		else
			if instr($args['результат'],'.')=0: $args['результат']+='.'
			$args['приближение']+='0'
		end
		if instr($args['результат'],'.')<>0: args[2]=args[2]/10
	else
		!@ если при попытке вычесть получаем положительный результат
		args['цифра']+=1	& !@ увеличиваем набираемую цифру
		$args['приближение']=$mid($args['вычитание'],2)	& !@ приближение теперь равно вычитанию
	end
	jump 'for'
end
$result=$args['+']+$func('#dz#',$args['результат'])
--- #:# ---------------------------------
!@pp:endif

Прежде данная функция выглядела так:
!# #:#
$args[9]=$args[9]
$args[0]=$func('#dz#',$args[0],1)
$args[1]=$func('#dz#',$args[1],1)
args[2] = args[2]
args['max']=max(func('#razdiv#',$args[0]),func('#razdiv#',$args[1]))
args[0] = func('#undiv#',$args[0],args['max'])
args[1] = func('#undiv#',$args[1],args['max'])
$result=$func('#indiv#',args[0],args[1],args[2])
!--- #:# ---------------------------------

Это давало повышенную скорость работы. Где-то в 10 раз быстрее. Однако это и накладывало некоторые ограничения на аргументы. Например, старая версия функции неверно вычисляла вот такие значения:
$func('#:#','3123.869504',"3.7",1000000)
= -316.512916

Теперь ограничение связано только с числом знаков после запятой, до которого можно выполнить вычисления.
= 844.289055

Функция использует функции #dz# #dev# и #zero#

!@pp:if(em_addition!=True):nopp
!@pp:var(em_dz)
!@pp:var(em_zstr)
!@pp:var(em_dev)
!@pp:endif
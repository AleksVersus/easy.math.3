QSP-Game Функция выполняет побайтовое сложение двух чисел с переполнением на последнем байте.
$args[0] - первое число (сколько угодно длинное), можно  args[0] (ограниченное значение).
$args[1] - второе число (сколько угодно длинное), можно  args[1] (ограниченное значение).
!@pp:if(em_byte_add):include
# em.byte.add
!@ x + (99999 - y + 1) - 100000
!@ получаем слагаемые
if $args[0]='': $args[0]=$str(args[0]) else $args[0] = $args[0]
if $args[1]='': $args[1]=$str(args[1]) else $args[1] = $args[1]
if no (strcomp($args[0], '\d+') and strcomp($args[1], '\d+')): $result = '[not a number]' & exit
local $x, $y = $args[0], $args[1]	& !@ локальные переменные для слагаемых
!@ получаем длину слагаемого с максимальной длиной (число разрядов)
local max_len_ = max(len($x), len($y))
!@ если число разрядов не кратно девяти, делаем его кратным девяти
local digital_ = iif(max_len_ mod 9 = 0, max_len_, (max_len_ / 9 + 1) * 9)
!@ локальные переменные для суммы и байта переполнения
local $sum_, overflow_byte_
loop local run_ = 1 while run_:
	!@ дополняем недостающие разряды
	$x = @em.zero(digital_ - len($x)) + $x
	$y = @em.zero(digital_ - len($y)) + $y
	!@ переназначаем сумму и байт переполнения
	$sum_, overflow_byte_ = '', 0
	!@ теперь с помощью цикла производим вычисления
	loop local i = digital_ while i > 0 step i -= 9:
		!@ складываем два девятизначных числа
		$sum_['9'] = $str(val($mid($x, i-9+1, 9)) + val($mid($y, i-9+1, 9)) + overflow_byte_)
		!@ максимальное число от сложения может быть 2 000 000 000
		!@ это значит, что может случиться переполнение по последнему байту
		if len($sum_['9'])>9:
			overflow_byte_ = val($mid($sum_['9'], 1, 1))
			$sum_['9'] = $mid($sum_['9'], 2)
		else:
			overflow_byte_ = 0
		end
		$sum_ = $sum_['9'] + $sum_
	end
	if overflow_byte_ > 0:
		!@ когда цикл завершён, может остаться значение в байте переполнения.
		!@ в этом случае нам снова нужно сложить два слагаемых, одно из которых
		!@ байт переполнения
		$x = $sum_	& !@ здесь сумма по идее имеет длину digital_
		$y = @em.zero(digital_ - len($str(overflow_byte_))) + $str(overflow_byte_)
	elseif val($mid($sum_, 1, len($sum_) - max_len_)) > 0:
		!@ так же, поскольку мы обрабатываем числа фиксированной длины,
		!@ нас не устроит, если эти числа изменят свою длину, а значит
		!@ нам снова нужно сложить два слагаемых. Теперь мы отрезаем от суммы
		!@ накрученные сверху разряды, делая их одним из слагаемых
		$x = $mid($sum_, len($sum_) - max_len_ + 1)
		$y = $mid($sum_, 1, len($sum_) - max_len_)
	else:
		!@ если ни один случай не сыграл, прерываем внешний цикл
		run_ = 0
	end
end
$result = @em.zero(max_len_ - len($sum_)) + $sum_
--- em.byte.add ---------------------------------
!@pp:endif

Функция использует функцию em.zero

!@pp:if(em_byte_add!=True):nopp
!@pp:var(em_zero)
!@pp:endif

@em.byte.add(998765,273)	& !@ '999038'
@em.byte.add('9987Y5','-273')	& !@ '[not a number]'
@em.byte.add('999999','6273')	& !@ '006273'
@em.byte.add('998705','5773')	& !@ '004479'

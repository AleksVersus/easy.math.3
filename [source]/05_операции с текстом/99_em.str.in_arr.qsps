QSP-Game Функция выбирает слова между разделителями в массив

!@ $0 - отрывок текста, который нужно разбить на строки
!@ $1 - имя массива, в который нужно поместить полученные строки
!@ $2 - разделитель, по которому нужно произвести выборку строк. По умолчанию - символ переноса строки.
!@ $3 - дополнительные опции (можно комбинировать):
!@pp:if(em_str_in_arr):include
# em.str.in_arr
!@pp:if(em_fuse):include
if $args[1] = '': msg 'em.str.in_arr: Wrong array name → <<$args[1]>>' & exit
if instr($args[1], '$') <> 1: msg 'em.str.in_arr: type prefix ''$'' not specified →  <<$args[1]>>' & exit
!@pp:endif
$args[3] = $lcase($args[3])
!@ по умолчанию разделителем является символ переноса строки
if $args[2] = '': $args[2] = @em.RN
if no instr($args[3], '[regular]'):
	$args[0] += $args[2]	& !@ если разделителем выступает не регулярка, разделитель добавляется в конец строки
else:
	$args[0] = $args[0]	& !@ если разделителем выступает регулярка, разделитель в конец строки не добавляется
end
!@ удаляем массивы, чтобы старые значения не мешали:
killvar $args[1]
local $easy_math_copy_array
loop while len($args[0]) > 0:
	if no instr($args[3], '[regular]'):
		args['div'] = instr($args[0], $args[2])	& !@ с какого символа разделитель входит в строку
		$args['div.'] = $args[2]	& !@ рассматриваемый разделитель совпадает с заданным
	else:
		args['div'] = strpos($args[0], $args[2])	& !@ с какого символа разделитель входит в строку
		$args['div.'] = $strfind($args[0], $args[2])	& !@ выбираем разделитель по регулярке
	end
	if args['div'] > 0:
		!@ если разделитель найден
		$args['vs'] = $mid($args[0], 1, args['div']-1)	& !@ вырезаем строку до разделителя
		$args[0] = $mid($args[0], args['div'] + len($args['div.']))	& !@ вырезаем строку после разделителя
	else:
		!@ если разделитель не найден
		$args['vs'] = $args[0]	& !@ последняя часть строки - искомая
		$args[0] = ''	& !@ строка после разделителя пустая
	end
	if ($args['vs'] <> '' and instr($args[3], '[notspace]')) or no instr($args[3], '[notspace]'):
		!@ если найденная строка не пуста и включен режим notspace, либо режим notspace отключён:
		$easy_math_copy_array[] = $args['vs']
	end
end
if instr($args[3],'[trim]'):
	!@ в режиме trim удаляем первый и последний элементы, если они пустые, либо содержат только разделители
	if $easy_math_copy_array[0] = '' or $easy_math_copy_array[0] = $args[2] or $easy_math_copy_array[0] = $args[2] + $args[2]:
		killvar '$easy_math_copy_array', 0
	end
	if $easy_math_copy_array[] = '' or $easy_math_copy_array[] = $args[2] or $easy_math_copy_array[] = $args[2] + $args[2]:
		killvar '$easy_math_copy_array', arrsize('$easy_math_copy_array')-1
	end
end
copyarr $args[1], '$easy_math_copy_array'	& !@ копируем временный массив в искомый
--- em.str.in_arr ---------------------------------
!@pp:endif
Из переданного блока текста выбираются строки, находящиеся между разделителями, в том числе строка до первого разделителя и после последнего. В качестве разделителя можно задать что угодно: символ, слово, строку. Для того, чтобы задать несколько разделителей, или неявный разделитель (шаблон разделителя. Например, html-тег), можно использовать регулярные выражения.
!@ $0 - отрывок текста, который нужно разбить на строки
!@ $1 - имя массива, в который нужно поместить полученные строки
!@ $2 - разделитель, по которому нужно произвести выборку строк. По умолчанию - символ переноса строки.
!@ $3 - дополнительные опции (можно комбинировать):
	[trim] - если строка до первого разделителя и/или строка после последнего разделителя окажутся пустыми, они не будут добавлены в массив,
	[notspace] - будут проигнорированы все пустые строки между разделителями,
	[regular] - указанный в $args[2] разделитель считается регулярным выражением.

Функция не использует иных функций библиотеки

$text="Адское Пекло и Небеса -
Я весь мир мечтаю продать.
Время - деньги. Пусть стрелки бегут на часах -
И мне нечего больше желать."

@em.str.in_arr($text,'$mass','
','')

loop local i,size=0,arrsize('$mass') while i<size step i+=1:
	*pl "$mass[<<i>>]=<<$mass[i]>>"
end

@em.str.in_arr($text,'$mass',' ','')

loop local i,size=0,arrsize('$mass') while i<size step i+=1:
	*pl "$mass[<<i>>]=<<$mass[i]>>"
end

@em.str.in_arr($text,'$mass','("|!|\?|-|,|;|:|\.| |
)','[notspace] [regular] [lcase]')

loop local i,size=0,arrsize('$mass') while i<size step i+=1:
	*pl "$mass[<<i>>]=<<$mass[i]>>"
end

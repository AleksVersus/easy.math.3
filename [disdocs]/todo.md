# Запланировано

<!--
	Вношу изменения списком. Затем, когда накапливается досточно изменений, делаю релиз новой версии
	3.2.1:
		3 - ветка библиотеки. Ветки будут изменяться с изменениями версии плеера
		2 - серьёзные изменения в функционировании библиотеки, либо нарушающие обратную совместимость
		1 - мелкие изменения и правки, не нарушающие обратную совместимость

-->

- [ ] `str.slice` кривовато работает. Брать срезы за пределами строки недопустимо.
- [ ] кэширование функций, работающих с большим количеством циклов или случайными значениями. Внимательно! Иногда нужно кэшировать не саму функцию, а только её внутреннюю логику, что приводит нас к необходимости выделять внутреннюю логику в отдельные функции.

## Переход на 5.9.3

- [x] функции `get_type` и `get_type_prefix` пересмотреть, и либо совсем убрать, либо заменить на более правильные с использованием `arrtype`


# Отложенные задачи. пока нет смысла решать

## Числа с плавающей точкой

> [!note]- Сокращение вычислений для чисел с плавающей точкой.
> 
> Вместо того, чтобы производить вычисления поразрядно, можно вычислять сразу по нескольку цифр. Логика при этом практически не меняется.
> Предел чисел 2 147 483 647
> То есть, чтобы всегда иметь в запасе 1 разряд, мы можем суммировать числа из 9 знаков одновременно.
> Быть может логично приводить число к количеству разрядов, кратному 9.

### Реализация через кортежи

Вместо того, чтобы хранить число в виде строки текста, его можно хранить в виде кортежа. В каждом из кортежей будет храниться по шесть шестизначных значений. Плюс множитель знака Как-то мне это не пришло в голову раньше.

`[123456, 123456, 123456, 123456, 123456, 123456, -1]`

Данный кортеж представляет собой число с фиксированной запятой, но при этом оно обеспечивает покрытие большинства нужд игры.

Такую запись можно рассматривать при любых операциях, как:

```math
 123456000000000000000000000000000000
+      123456000000000000000000000000
+            123456000000000000000000
+                  123456000000000000
+                        123456000000
+                              123456
-------------------------------------
 123456123456123456123456123456123456
```

Фиксированная запятая всегда после третьего числа. Множитель знака необходим для операций сложения.

## поиск в ряде чисел ближайшего к указанному промежутку

Эта задача даст решение для поиска первых приближений корня квадратного.

## switch/case

Можно написать функцию, анализирующую кейсы, которая будет позволять проще записывать сложные условия.

```qsp
{
	switch x:
		0: x*=99
		1: x*=88
		2: x*=77
		3: x*=66
		else: x*=11
	end
}
!@ преобразуется в
if 0:
	elseif x = 0: x*=99
	elseif x = 1: x*=88
	elseif x = 2: x*=77
	elseif x = 3: x*=66
	else: x*=11
end
```


```qsp
{
	1: {
		act "Сплясать Джигу":
			*pl "Ноги сами пустились в пляс, голова завертелась волчком. Джигадрыгай и в профиль и в фас. Всё пучком!"
		end
	}
	2: {
		act "Вальсировать":
			*pl "Раз, два, три... Раз, два, три..."
		end
	}
	3: {
		act "Твист":
			*pl "Первый окурок давим правым ботинком, второй окурок давим левым ботинком. А теперь оба окурка давим вместе."
		end
	}
	4: {
		act "Танцевать Пого":
			"Пели песни до утра, пого танцевали..."
		end
	}
	5: {
		act "Капуэйро":
			"Вжух-вжух!.."
		end
	}
}
```

## Обработка HTML-тега

функция, заменяющая содержимое указанного тега в окне основного описания на новое. (сомнительно, рассмотреть для игровых тегов)

в easy.test написана функция, заменяющая содержимое указанного тега в окне основного описания на новое. Пока работает только с уникальными названиями тегов. Необходимо дать возможность указывать name или id тега и по нему заменять содержимое. Т.е. независимо от непосредственно названия тега.

```qsp
! данная функция заменяет содержимое XML/HTML-тега в основном окне 
! на указанное, либо выводит содержимое в этом теге,
! если такой тег не существует
$args[0]=$args[0]	&	!	содержимое
$args[1]=$args[1]	&	!	название тега
! получаем снимок окна основного описания
$args['main_text']=$maintxt
! получаем тег и его содержимое в окне основного описания
$args['color_test']=$strfind($args['main_text'],'<'+$args[1]+'>[\s\S]*?<\/'+$args[1]+'>')
! тег с новым содержимым
$args['new']='<'+$args[1]+'>'+$args[0]+'</'+$args[1]+'>'
if $args['color_test']="":
	! сначала перевод строки, затем вывод
	*nl $args['new']
else
	$args['main_text']=$replace($args['main_text'],$args['color_test'],$args['new'])
	*clr
	! вывод
	*p $args['main_text']
end
```